# product_gui.py
# France Cheong
# 11/12/2018

# ########
# Packages
# ########
import tkinter as tk
from tkinter import messagebox
import tkinter.ttk as ttk # for combobox

# #################################################
# Import any of your classes defined in other files
# #################################################

import database as db # Import database.py to get a session to a particular db
# From file xxx.py import class Xxxx
from paydetails_dao import PaydetailsDAO # To communicate with Product table
from validation import Validation # To validate the entries made on the form

class PaydetailsGUI():

    def __init__(self):   


        # Instantiate a data access object 
        # Contains methods to access the database
        self.payd_dao = PaydetailsDAO()

        # Instantiate a validation object
        # Contains methods to validate input fields
        self.validator = Validation()

        # Form fields
        # Instantiate stringvars to hold the data entered on the form
        self.pay_details_id = tk.StringVar()
        self.hourly_rate = tk.StringVar()
        self.total_hours = tk.StringVar()
        self.net_pay = tk.StringVar()
        self.total_deductions = tk.StringVar()
        self.total_pay = tk.StringVar()
        self.pay_slip_id = tk.StringVar()

        # List of product ids - lb for listbox
        self.lb_ids = None

        # Messagebox title
        self.mb_title_bar = "Paydetails CRUD"


    def create_gui(self, root):
        """
        Create a high level frame which contains the entire GUI 
        (of this part of the application) and adds it to the root window.
        Notice that the "root" window is passed the second parameter in the 
        method header.
        Also notice that the first (and mandatory) parameter to all methods 
        is "self" i.e. a reference to the object instantiated from the class.

        Widgets like labels, entries, etc  (including inner frames) are 
        added to the high level frame 
        At the end, the function return a reference to the frame that was 
        created for the calling program to be able to access it.

        Parameters (apart from self):
            root: main window of application

        Return: 
            prod_frame: the frame containing all the widgets for the product CRUD
        """

        print("Creating Paydetails GUI ...")

        # Add a high level frame - will contain the entire product GUI
        payd_frame = tk.Frame(root)
        payd_frame.pack()

        # Add a frame to contain the form widgets
        form_frame = tk.Frame(payd_frame)
        form_frame.pack()

        tk.Label(form_frame, font=('arial', 10), 
                 text = "Paydetails").grid(row=0, column=0, columnspan=3)

        # row 1: employee_id label, employee_id entry and list_of_ids label
        tk.Label(form_frame, text= "Paydetails Id", font=('arial', 10), width=20, 
                 anchor="e", bd=1, pady=10, padx=10).grid(row=1, column=0)
        # Need to use both padx and pady to leave a vertical space between rows of labels
        # And a space between the  label and its entry field
        # For 'tkinter Entry' options, 
        # refer to http://effbot.org/tkinterbook/entry.htm
        # Entry has no padding options
        # Use the width= option to specify how wide in terms of number of characters
        tk.Entry(form_frame, textvariable=self.pay_details_id, width=30, bd=1, 
                 state=tk.DISABLED).grid(row=1, column=1)
        # employee_id is disabled to prevent user from entering a value
        # employee_id is generated by the database because AUTOINCREMENT 
        # was specified in the database schema
        tk.Label(form_frame, text= "Paydetails IDs", 
                 font=('arial', 10)).grid(row=1, column=2)
        
        # row 2: firstname label, firstname entry and listbox of ids
        tk.Label(form_frame, text= "Hourly Rate", font=('arial', 10), 
                 width=20, anchor="e", bd=1, pady=10, padx=10).grid(row=2, column=0)
        tk.Entry(form_frame, textvariable=self.hourly_rate, 
                 width=30, bd=1).grid(row=2, column=1)
        
        tk.Label(form_frame, text= "Total Hours", font=('arial', 10), 
                 width=20, anchor="e", bd=1, pady=10, padx=10).grid(row=3, column=0)
        tk.Entry(form_frame, textvariable=self.total_hours, 
                 width=30, bd=1).grid(row=3, column=1)
        # For 'tkinter Listbox' options, 
        # refer to http://effbot.org/tkinterbook/listbox.htm
        # Use the height= option to specify the height, default is 10
        # Use the width= option to specify the number of characters, default is 20
        self.lb_ids = tk.Listbox(form_frame)
        self.lb_ids.grid(row=2, column=2, rowspan=5) 
        # 'self' means instance attribute rather than local variable
        # since python allows using variables before they are declared
        # it does not matter whether lb_ids has been declared or not at the 
        # top of the file before the methods definition
        # Set the method to be called when an item is clicked on the listbox 
        self.lb_ids.bind('<<ListboxSelect>>', self.on_list_select)

        # row 3: lastname label and entry (the listbox will go through)
        tk.Label(form_frame, text= "Net Pay", font=('arial', 10), width=20, 
                 anchor="e", bd=1, pady=10, padx=10).grid(row=4, column=0)
        tk.Entry(form_frame, textvariable=self.net_pay, 
                 width=30, bd=1).grid(row=4, column=1)

        # row 4: title label and combobox (the listbox will go through)
        tk.Label(form_frame, text= "Total Deductions", font=('arial', 10), width=20, 
                 anchor="e", bd=1, pady=10, padx=10).grid(row=5, column=0)
        # Readonly combobox - prevent the user from adding values
        # For 'tkinter Combobox' options, 
        # refer to https://docs.python.org/3.1/library/tkinter.ttk.html
        # Cannot find a good reference!
        # The state= option is either "normal" for read/write or "readonly" 
        # to prevent the user from adding values
        tk.Entry(form_frame, textvariable=self.total_deductions, 
                 width=30, bd=1).grid(row=5, column=1)
        # Display first value - prevents a blank value being displayed (and selected!)          
    
        
        # row 5: email label and combobox (the listbox will go through)
        tk.Label(form_frame, text= "Total Pay", font=('arial', 10), 
                 width=20, anchor="e", bd=1, pady=10, padx=10).grid(row=6, column=0)
        tk.Entry(form_frame, textvariable=self.total_pay, width=30, bd=1).grid(row=6, column=1)

        # row 6: work_phone label and combobox (the listbox will go through)
        tk.Label(form_frame, text= "Payslip ID", font=('arial', 10), width=20, 
                 anchor="e", bd=1, pady=10, padx=10).grid(row=7, column=0)
        tk.Entry(form_frame, textvariable=self.pay_slip_id, 
                 width=30, bd=1).grid(row=7, column=1)
        
    
        # def print_sel():
        #    print(cal.selection_get())
             
        # top = tk.Toplevel(root)

        # cal = Calendar(top, font="Arial 14", selectmode='day', locale='en_US',
        #            cursor="hand1", year=2018, month=2, day=5)

        # cal.pack(fill="both", expand=True)
        # ttk.Button(top, text="ok", command=print_sel).pack()
        
 

        # Buttons
        # There are 3 columns of widgets in the frame and 4 buttons
        # Better insert the button in another frame
        # Also easier to pack them from the left than using a grid with row 
        # and col locations
        # pady to leave a space from frame on top
        button_frame = tk.Frame(payd_frame, pady=10) 
        button_frame.pack()
        # For 'tkinter Button' options, 
        # refer to http://effbot.org/tkinterbook/button.htm
        # Use the anchor= option to position the button
        # External padding around buttons: padx= pady=  default is 0
        # Use the width= option to specify the number of characters, 
        # otherwise calculated based on text width
        tk.Button(button_frame, width=10, text="Clear", 
                  command=self.clear_fields).pack(side=tk.LEFT)
        tk.Button(button_frame, width=10, text="Save", 
                  command=self.save).pack(side=tk.LEFT)
        tk.Button(button_frame, width=10, text="Delete", 
                  command=self.delete).pack(side=tk.LEFT)
        tk.Button(button_frame, width=10, text="Load", 
                  command=self.load).pack(side=tk.LEFT)       

        # Return a reference to the high level frame created
        # Will need the reference to be able to destroy it in the calling function
        return payd_frame

    def clear_fields(self):
        """
        Clear the fields of the form

        Parameters (apart from self): None

        Return: None
        """

        # Just blank all the fields
        self.pay_details_id.set("")
        self.hourly_rate.set("")
        self.total_hours.set("")
        #self.title.set("") # Do not clear if using dropdown
        self.net_pay.set("")
        self.total_deductions.set("")
        self.total_pay.set("")
        self.pay_slip_id.set("")
        pass

    def save(self):
        """
        Save the data displayed on the form to the database.
        The employee data to be saved is obtained from the global 
        instance attributes.
        The data is validated by calling another method called validate_fields()
        If the data is invalid, a message box is presented to the user.
        If the data is valid, the data is either saved or updated
        If an employee_id is present, the data is updated
        If not, a new employee record is create in the database
 
        Parameters (apart from self): None
 
        Return: None
            
        """

        print("Saving paydetails ...")

        # Get the data
        data = self.get_fields()   

        # Validate the data
        valid_data, message = self.validate_fields(data)
        if valid_data:
            if (len(data['pay_details_id'])==0):
                # If nothing has been entered in employee_id 
                # i.e. its length is zero characters
                print("Calling create() as pay_details_id is absent")
                self.create(data)
            else:
                print("Calling update() as pay_details_id is present")
                self.update(data)
                pass
        else:
            message_text = "Invalid fields.\n" + message 
            messagebox.showwarning(self.mb_title_bar, message_text, icon="warning")
            pass

    def get_fields(self):
        """
        Get the data entered in the fields of the form

        Parameters (apart from self): None

        Return:
            emp: dictionary object containing all the information 
                 about an employee
        """

        paydict = {}

        paydict['pay_details_id'] = self.pay_details_id.get()
        paydict['hourly_rate'] = self.hourly_rate.get() 
        paydict['total_hours'] = self.total_hours.get()
        paydict['net_pay'] = self.net_pay.get() 
        paydict['total_deductions'] = self.total_deductions.get() 
        paydict['total_pay'] = self.total_pay.get() 
        paydict['pay_slip_id'] = self.pay_slip_id.get()
        return paydict  

    def validate_fields(self, data):
        """
        Validate the data entered in the fields of the form

        Parameters (apart from self):
            data: dictionary object containing all the information entered on the form

        Return:
             valid_data: a boolean indication whether the data is valid 
                         (True) or not valid (False)
             message: a string containing details about the fields that are not valid
             Note: when these values are returned as a tuple 
                   (valid_data, message) i.e. a list that cannot be changed

        """
           
        # By default set to true, anything wrong will turn it to false   
        valid_data = True 
        # Instantiate an empty list to contain the messages
        message_list = [] 
        # Check for blank fields
        # Do not check employee_id as this is generated by the database
        #if len(data['employee_id']==0:
        #    valid_data = False
        #    message_list.append("employee_id is empty")
        if len(data['hourly_rate'])==0:
            valid_data = False
            message_list.append("Hourly rate is empty")
        if len(data['total_hours'])==0:
            valid_data = False
            message_list.append("Total Hours is empty")
        if len(data['net_pay'])==0:
            valid_data = False
            message_list.append("Net Pay is empty")
        if len(data['total_deductions'])==0:
            valid_data = False
            message_list.append("Total deductions is empty")
        if len(data['total_pay'])==0:
            valid_data = False
            message_list.append("Total Pay is empty")
        if len(data['pay_slip_id'])==0:
            valid_data = False
            message_list.append("Pay slip ID is empty")

        # Other possible checks

        # Implement these as functions in the Validation class so that 
        # other classes can call them
         
        # Check if firstname and lastname contain  
        # only alphabetic characters (and may be certain special characters)
        if not self.validator.is_numeric(data['hourly_rate']):
            valid_data = False
            message_list.append("invalid hourly rate")

        if not self.validator.is_numeric(data['total_hours']):
            valid_data = False
            message_list.append("invalid total hours")
    
        # Check if work_phone follows a certain pattern 
        # i.e. (02) 99999999 or (02) 9999 9999 or +61 3 9999 9999 (international)
        #if not self.validator.is_phone_number(data['work_phone']):
        #    valid_data = False
        #    message_list.append("invalid phone number format")
        
            
        # Join the items in the list as a string separated with a comma and a space    
        message = ', '.join(message_list) 

        return valid_data, message # return 2 values

    def create(self, data):
        """
        Create a new record in the database.
        A messagebox is used display the outcome (success or failure) 
        of the create operation to the user.

        Parameters (apart from self):
            data: dictionary object containing employee data to be saved
 
        Return: None
        """

        print("Creating paydetails ...")
        print(data)

        session = db.get_db_session() # Get a session (database.py)
        result = self.payd_dao.create(session, data) 
          # result is a tuple e.g. ("Employee added successfully", 1004) 
        #result, employee_id = self.emp.create(data) 
          # if you wish to get the message and employee_id separately
        session.close() # Close the session

        # Display the returned message to the user - use a messagebox
        # For 'tkinter messagebox' options, 
        # refer to http://effbot.org/tkinterbook/tkinter-standard-dialogs.htm
        # Format: message.function(title, message [, options])
        # Functions: showinfo, showwarning, showerror, askquestion, 
        #            askokcancel, askyesno, or askretrycancel
        # Use the icon= option to specify which icon to display 
        # e.g. icon="warning", "error", "info", "question"     
        # Display everything that is returned in the result
        messagebox.showinfo(self.mb_title_bar, result)
 
        pass

    def update(self, data):
        """
        Update a record in the database
        A messagebox is used display the outcome (success or failure) 
        of the update operation to the user.

        Parameters (apart from self):
            data: dictionary object containing employee data to be saved
 
        Return: None
        """

        print("Updating paydetails ...")
        print(data)

        session = db.get_db_session() # Get a session (database.py)
        result = self.payd_dao.update(session, data['pay_details_id'], data)
        session.close() # close the session

        # Display the returned message to the user - use a messagebox  
        # Display everything that is returned in the result      
        messagebox.showinfo(self.mb_title_bar, result)
        pass

    def delete(self):
        """
        Delete a record from the database
        The employee_id of the record to be deleted is obtained from a 
        global attribute.

        A messagebox is used display the outcome (success or failure) 
        of the delete operation to the user.

        Parameters (apart from self): None
 
        Return: None

        """

        # Grab the employee_id from the stringvar
        id = self.pay_details_id.get() 
        print(id)
        
        # Call the data access object to do the job
        # Pass the id as parameter to the delete() method
        session = db.get_db_session() # Get a session (database.py)
        result = self.payd_dao.delete(session, id)
        session.close() # Close the session

        # Display the returned message to the user - use a messagebox    
        # Display everything that is returned in the result    
        messagebox.showinfo(self.mb_title_bar, result)
        pass

    def load(self):
        """
        Retrieve a list of IDs from the database and load them into a listbox
 
        Parameters (apart from self):
  
        Return: None
        """

        session = db.get_db_session() # Get a session (database.py)
        result = self.payd_dao.find_ids(session) #
        session.close() # Close the session
        print("result", result)
        # Check if there is an entry in the result dictionary
        if "pay_details_id" in result: 
            list_ids = result['pay_details_id'] # will crash if there is no entry!
            # Set the returned list into the listbox
            # Before doing that, must clear any previous list in the box
            self.lb_ids.delete(0,tk.END)
            print("Setting paydetails_id in listbox ...")
            for x in list_ids:
                self.lb_ids.insert(tk.END, x)
                #print(x)
            pass

    def on_list_select(self, evt):
        """
        on_list_select() is triggered when a user clicks an item in the listbox.
        This was defined with the statement 
        "self.lb_ids.bind('<<ListboxSelect>>', self.on_list_select)" 
        defined above in create_gui()

        Parameters (apart from self):
            evt: object containing information about the mouse click

        Return: None
        """
        # For more information on 'tkinter events', 
        # refer to http://effbot.org/tkinterbook/tkinter-events-and-bindings.htm
        w = evt.widget
        index = int(w.curselection()[0]) 
          # index = position of the item clicked in the list, first item is item 0 not 1
        value = w.get(index) 
          # value of the item clicked, in our case it's the employee_id
        print(index) 
        print(value)

        # Call find_by_id and populate the stringvars of the form
        session = db.get_db_session() # Get a session (database.py)
        result = self.payd_dao.find_by_id(session, value)   
        session.close() # close the session
        print("result", result) 
           # { "employee" : {"employee_id": "", "firstname": "", etc}}
        payd = result['paydetails']
        self.populate_fields(payd)
        pass

    def populate_fields(self, payd):
        """
        Populate the fields of the form with data

        Parameters (apart from self):
            emp: dictionary object containing all the information about an employee

        Return:
        """

        # Set the values from the dict to the stringvars
        self.pay_details_id.set(payd['pay_details_id'])
        self.hourly_rate.set(payd['hourly_rate'])
        self.total_hours.set(payd['total_hours'])
        #self.title.set("") # Do not clear if using dropdown
        self.net_pay.set(payd['net_pay'])
        self.total_deductions.set(payd['total_deductions'])
        self.total_pay.set(payd['total_pay'])
        self.pay_slip_id.set(payd['pay_slip_id'])
        pass

# ###########
# Main method
# ###########

if __name__ == '__main__':
    """
    The main method is only executed when the file is 'run' 
    (not imported in another file)
    """
     
    # Setup a root window (in the middle of the screen)
    root = tk.Tk()
    root.title("Payroll System")
    screen_width = root.winfo_screenwidth()
    screen_height = root.winfo_screenheight()
    width = 900
    height = 500
    x = (screen_width/2) - (width/2)
    y = (screen_height/2) - (height/2)
    root.geometry('%dx%d+%d+%d' % (width, height, x, y))
    root.resizable(0, 0)

    # Instantiate the gui
    gui = PaydetailsGUI()

    # Create the gui
    # pass the root window as parameter
    gui.create_gui(root)

    # Run the mainloop 
    # the endless window loop to process user inputs
    root.mainloop()
    pass