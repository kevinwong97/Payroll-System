
# Import packages
# From file xxx.py import class Xxxx
# Note: Filenames with hyphens cannot be imported, use underscores
from dateutil.parser import parse
from schema import Employee

class EmployeeDAO():

    def create(self, session, data):

        # Print info for debugging
        print("\nCreating an employee ...") #\n means print("\n") a blank line
        print(data)

        # Instantiate an object of the mapped Employee class - defined in schema.py
        # SKip the employee_id when inserting as it will be generated by the database
        employee = Employee(
                    firstname = data['firstname'], 
                    lastname = data['lastname'], 
                    title = data['title'], 
                    email = data['email'],
                    work_phone = data['work_phone'],
                    date_employed = data['date_employed'],
                    employer_id = data['employer_id']
                    )

        # Get the session to add the employee object
        session.add(employee)
        session.commit() # Must commit to save the record permanently

        # Create a blank dictionary to return the result
        result = {}  
        result['message'] = 'Employee added successfully!'
        inserted_employee_id = employee.employee_id
        result['employee_id'] = inserted_employee_id

        return result # return the result as a dictionary   

    def find_by_id(self, session, employee_id):

        # Print info for debugging
        print("\nFinding an employee ...")
        print(employee_id)

        # Get the session to query the Employee class
        # And get by the primary key i.e. employee_id
        emp = session.query(Employee).get(employee_id) 
        
        # Create a blank dictionary to return the result
        result = {}

        # emp is a single Alchemy object - no need for a loop to process
        if not emp:
            # If no employee found i.e. emp is none
            result['message'] = "Employee NOT found"
        else:
            # Else grab the values in the returned SQLalchemy object
            # And build another python dictionary
            d = {} # Create an empty dict and add items to it
            d['employee_id'] = emp.employee_id # include the employee_id
            d['firstname'] = emp.firstname
            d['lastname'] = emp.lastname
            d['title'] = emp.title
            d['email'] = emp.email
            d['work_phone'] = emp.work_phone
            d['date_employed'] = emp.date_employed
            d['employer_id'] = emp.employer_id

            # Store the employee dict in the result dict under key "employee"
            result['employee'] = d
            #session.commit() # not needed for find as not saving changes            
        
        # Note that the return is not part of the if/else block
        # Ensure it's indented to the left
        return result # return the result as a dictionary

    def find_by_lastname(self, session, lastname): 

        # Print info for debugging
        print("\nFinding employee(s) by lastname ...")
        print(lastname)

        # Create a blank dictionary to return the result
        result = {}

        # Line is too long for display > 80 chars 
        # Use line continuation character at sensible places
        # Get the session to query the Employee class and filter and order all
        rows = session.query(Employee) \
               .filter(Employee.lastname.like(lastname)) \
               .order_by(Employee.employee_id).all()   

        if not rows:
            result['message'] = "No employees found!"
        else:
            # Convert list of Alchemy employee objects to a list of dictionaries
            # This query could return more than one employees - so create a list
            list_emp = [] # Create an empty list to append employee dicts
            for x in rows: # rows is a list of Alchemy objects - process one by one
                d = {} # Create an empty dict and add items to it
                d['employee_id'] = x.employee_id
                d['firstname'] = x.firstname
                d['lastname'] = x.lastname
                d['title'] = x.title
                d['email'] = x.email
                d['work_phone'] = x.work_phone
                d['date_employed'] = x.date_employed
                d['employer_id'] = x.employer_id
                list_emp.append(d) # Append the employee dict to the employee list
                pass     

            # Store the employee list in the result dict under key "employees"              
            result['employees'] = list_emp
           
        return result  # return the result as a dictionary   

    def find_all(self, session):

        # Print info for debugging
        print("\nFinding all employees ...")

        # Create a blank dictionary to return the result
        result = {}

        # Get the session to query the Employee class and get all (may wish to sort)
        rows = session.query(Employee).all()

        if not rows:
            result['message'] = "No employees found!"
        else:
            # Convert list of Alchemy objects to a list of dictionaries
            list_emp = [] # Create an empty list to append employee dicts
            for x in rows: # rows is a list of Alchemy objects - process one by one
                d = {} # Create an empty dict and add items to it
                d['employee_id'] = x.employee_id
                d['firstname'] = x.firstname
                d['lastname'] = x.lastname
                d['title'] = x.title
                d['email'] = x.email
                d['work_phone'] = x.work_phone
                d['date_employed'] = x.date_employed
                d['employer_id'] = x.employer_id
                list_emp.append(d) # Append the employee dict to the employee list
                pass  

            # Store the employee list in the result dict under key "employees"                 
            result['employees'] = list_emp
            
        return result # return the result as a dictionary

    def find_ids(self, session):
        """
        This is a special method similar to find_all but returns employee_ids only, 
        not the full details
        """

        # Print info for debugging
        print("\nFinding all employee ids ...")

        # Create a blank dictionary to return the result
        result = {}
 
        # Get the list of employees from the database
        rows = session.query(Employee).all()

        if not rows:
            result['message'] = "No employees found!"
        else:
            # Convert list of Alchemy objects to a list of dictionaries
            list_ids = []
            for x in rows:
                list_ids.append(x.employee_id)
                pass               

            # Store the list of ids in the result dict under key "employee_ids"
            result['employee_ids'] = list_ids
        
        return result # return the result as a dictionary

    def update(self, session, employee_id, data):

        # Print info for debugging
        print("\nUpdating employee ...")
        print(employee_id)
        print(data)

        # Create a blank dictionary to return the result
        result = {}

        # Find the employee record
        # What happens if the employee is not found?
        emp = session.query(Employee).get(employee_id)

        # Need to find out which field has changed!
        # Just update all fields
        #emp.employee_id = data['employee_id'] # Not the primary key!
        emp.firstname = data['firstname']
        emp.lastname = data['lastname']
        emp.title = data['title']
        emp.email = data['email']
        emp.work_phone = data['work_phone']
        emp.date_employed = data['date_employed']
        emp.employer_id = data['employer_id']

        session.commit() # Don't forget to commit 

        # Store an appropriate message in the result dict under key "message"
        result['message'] = "Employee updated!"     

        return result # return the result as a dictionary

    def delete(self, session, employee_id):

        # Print info for debugging
        print("\nDeleting employee ...")
        print(employee_id)
 
        # Create a blank dictionary to return the result
        result = {}

        # Find the record and get the session to delete it   
        # What happens if the employee is not found?      
        emp = session.query(Employee).get(employee_id)
        session.delete(emp)          
        session.commit()   # Don't forget to commit    

        # Store an appropriate message in the result dict under key "message"
        result['message'] = "Employee deleted"    

        return result # return the result as a dictionary    
